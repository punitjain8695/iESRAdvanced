
password_eeprom.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d6a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000008a  00800060  00000d6a  00000dde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000042  008000ea  00000df4  00000e68  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000114  00000000  00000000  00000e88  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000e23  00000000  00000000  00000f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000028c  00000000  00000000  00001dbf  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001048  00000000  00000000  0000204b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000d0  00000000  00000000  00003094  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001a7  00000000  00000000  00003164  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000079d  00000000  00000000  0000330b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001b0  00000000  00000000  00003aa8  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e6       	ldi	r30, 0x6A	; 106
  68:	fd e0       	ldi	r31, 0x0D	; 13
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	aa 3e       	cpi	r26, 0xEA	; 234
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	aa ee       	ldi	r26, 0xEA	; 234
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ac 32       	cpi	r26, 0x2C	; 44
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 82 03 	call	0x704	; 0x704 <main>
  8a:	0c 94 b3 06 	jmp	0xd66	; 0xd66 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>

00000092 <lcd_command>:
lcd_command(0X0c);		// screen on cursor off
lcd_command(0X06);		//auto increment
}

void lcd_command(char cmd)
{
  92:	28 2f       	mov	r18, r24
  94:	20 7f       	andi	r18, 0xF0	; 240
  96:	25 bb       	out	0x15, r18	; 21

LCD=(cmd&0xf0);
LCD&=~(1<<rs);
  98:	a8 98       	cbi	0x15, 0	; 21
LCD&=~(1<<rw);
  9a:	a8 98       	cbi	0x15, 0	; 21
LCD|=(1<<en);
  9c:	aa 9a       	sbi	0x15, 2	; 21
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  9e:	20 e4       	ldi	r18, 0x40	; 64
  a0:	3f e1       	ldi	r19, 0x1F	; 31
  a2:	f9 01       	movw	r30, r18
  a4:	31 97       	sbiw	r30, 0x01	; 1
  a6:	f1 f7       	brne	.-4      	; 0xa4 <lcd_command+0x12>
_delay_ms(2);		
LCD&=~(1<<en);
  a8:	aa 98       	cbi	0x15, 2	; 21

LCD=(cmd<<4)&0xf0;
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	44 e0       	ldi	r20, 0x04	; 4
  ae:	88 0f       	add	r24, r24
  b0:	99 1f       	adc	r25, r25
  b2:	4a 95       	dec	r20
  b4:	e1 f7       	brne	.-8      	; 0xae <lcd_command+0x1c>
  b6:	85 bb       	out	0x15, r24	; 21
LCD|=(1<<en);
  b8:	aa 9a       	sbi	0x15, 2	; 21
  ba:	c9 01       	movw	r24, r18
  bc:	01 97       	sbiw	r24, 0x01	; 1
  be:	f1 f7       	brne	.-4      	; 0xbc <lcd_command+0x2a>
_delay_ms(2);
LCD&=~(1<<en);
  c0:	aa 98       	cbi	0x15, 2	; 21

}
  c2:	08 95       	ret

000000c4 <lcd_init>:
#define LCD PORTC
#define en 2
char *str;

void lcd_init()
{
  c4:	82 e0       	ldi	r24, 0x02	; 2
  c6:	90 e0       	ldi	r25, 0x00	; 0
  c8:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0X02);		// home screen
lcd_command(0X28);		// 4 bit mode
  cc:	88 e2       	ldi	r24, 0x28	; 40
  ce:	90 e0       	ldi	r25, 0x00	; 0
  d0:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0X0c);		// screen on cursor off
  d4:	8c e0       	ldi	r24, 0x0C	; 12
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0X06);		//auto increment
  dc:	86 e0       	ldi	r24, 0x06	; 6
  de:	90 e0       	ldi	r25, 0x00	; 0
  e0:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
}
  e4:	08 95       	ret

000000e6 <lcd_data>:
LCD&=~(1<<en);

}

void lcd_data(char data)
{
  e6:	28 2f       	mov	r18, r24
  e8:	20 7f       	andi	r18, 0xF0	; 240
  ea:	25 bb       	out	0x15, r18	; 21
LCD=data&0xf0;
LCD|=(1<<rs);
  ec:	a8 9a       	sbi	0x15, 0	; 21
LCD|=(1<<en);
  ee:	aa 9a       	sbi	0x15, 2	; 21
  f0:	20 e4       	ldi	r18, 0x40	; 64
  f2:	3f e1       	ldi	r19, 0x1F	; 31
  f4:	f9 01       	movw	r30, r18
  f6:	31 97       	sbiw	r30, 0x01	; 1
  f8:	f1 f7       	brne	.-4      	; 0xf6 <lcd_data+0x10>
_delay_ms(2);
LCD&=~(1<<en);
  fa:	aa 98       	cbi	0x15, 2	; 21

LCD=(data<<4)&0xf0;
  fc:	90 e0       	ldi	r25, 0x00	; 0
  fe:	54 e0       	ldi	r21, 0x04	; 4
 100:	88 0f       	add	r24, r24
 102:	99 1f       	adc	r25, r25
 104:	5a 95       	dec	r21
 106:	e1 f7       	brne	.-8      	; 0x100 <lcd_data+0x1a>
 108:	85 bb       	out	0x15, r24	; 21
LCD|=(1<<rs);
 10a:	a8 9a       	sbi	0x15, 0	; 21
LCD|=(1<<en);
 10c:	aa 9a       	sbi	0x15, 2	; 21
 10e:	c9 01       	movw	r24, r18
 110:	01 97       	sbiw	r24, 0x01	; 1
 112:	f1 f7       	brne	.-4      	; 0x110 <lcd_data+0x2a>
_delay_ms(2);
LCD&=~(1<<en);
 114:	aa 98       	cbi	0x15, 2	; 21
}
 116:	08 95       	ret

00000118 <lcd_string>:



void lcd_string(unsigned char *str)
{
 118:	ef 92       	push	r14
 11a:	ff 92       	push	r15
 11c:	1f 93       	push	r17
 11e:	cf 93       	push	r28
 120:	df 93       	push	r29
 122:	ec 01       	movw	r28, r24
 124:	10 e0       	ldi	r17, 0x00	; 0
 126:	60 ea       	ldi	r22, 0xA0	; 160
 128:	e6 2e       	mov	r14, r22
 12a:	6f e0       	ldi	r22, 0x0F	; 15
 12c:	f6 2e       	mov	r15, r22
 12e:	06 c0       	rjmp	.+12     	; 0x13c <lcd_string+0x24>
char d=0;

while(str[d]!='\0')
{
lcd_data(str[d]);
 130:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
d++;
 134:	1f 5f       	subi	r17, 0xFF	; 255
 136:	c7 01       	movw	r24, r14
 138:	01 97       	sbiw	r24, 0x01	; 1
 13a:	f1 f7       	brne	.-4      	; 0x138 <lcd_string+0x20>

void lcd_string(unsigned char *str)
{
char d=0;

while(str[d]!='\0')
 13c:	fe 01       	movw	r30, r28
 13e:	e1 0f       	add	r30, r17
 140:	f1 1d       	adc	r31, r1
 142:	80 81       	ld	r24, Z
 144:	88 23       	and	r24, r24
 146:	a1 f7       	brne	.-24     	; 0x130 <lcd_string+0x18>
{
lcd_data(str[d]);
d++;
_delay_ms(1);
}
}
 148:	df 91       	pop	r29
 14a:	cf 91       	pop	r28
 14c:	1f 91       	pop	r17
 14e:	ff 90       	pop	r15
 150:	ef 90       	pop	r14
 152:	08 95       	ret

00000154 <lcd_number>:




void lcd_number(unsigned int no)
{
 154:	cf 93       	push	r28
 156:	df 93       	push	r29
 158:	ec 01       	movw	r28, r24

lcd_command(0x04);
 15a:	84 e0       	ldi	r24, 0x04	; 4
 15c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
int value=0;

if (no==0)
 160:	20 97       	sbiw	r28, 0x00	; 0
 162:	91 f4       	brne	.+36     	; 0x188 <lcd_number+0x34>
	lcd_data('0');
 164:	80 e3       	ldi	r24, 0x30	; 48
 166:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
 16a:	0e c0       	rjmp	.+28     	; 0x188 <lcd_number+0x34>
while(no!=0)
{
	value = no%10;
	lcd_data(48+value);
 16c:	ce 01       	movw	r24, r28
 16e:	6a e0       	ldi	r22, 0x0A	; 10
 170:	70 e0       	ldi	r23, 0x00	; 0
 172:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__udivmodhi4>
 176:	80 5d       	subi	r24, 0xD0	; 208
 178:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
	no=no/10;
 17c:	ce 01       	movw	r24, r28
 17e:	6a e0       	ldi	r22, 0x0A	; 10
 180:	70 e0       	ldi	r23, 0x00	; 0
 182:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__udivmodhi4>
 186:	eb 01       	movw	r28, r22
lcd_command(0x04);
int value=0;

if (no==0)
	lcd_data('0');
while(no!=0)
 188:	20 97       	sbiw	r28, 0x00	; 0
 18a:	81 f7       	brne	.-32     	; 0x16c <lcd_number+0x18>
{
	value = no%10;
	lcd_data(48+value);
	no=no/10;
}
lcd_command(0x06);
 18c:	86 e0       	ldi	r24, 0x06	; 6
 18e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
}
 192:	df 91       	pop	r29
 194:	cf 91       	pop	r28
 196:	08 95       	ret

00000198 <lcd_num>:



void lcd_num(unsigned int no)
{
 198:	0f 93       	push	r16
 19a:	1f 93       	push	r17
 19c:	8c 01       	movw	r16, r24
lcd_command(0x04);
 19e:	84 e0       	ldi	r24, 0x04	; 4
 1a0:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
int value=0;
value=no%10;
lcd_data(48+value);
 1a4:	c8 01       	movw	r24, r16
 1a6:	6a e0       	ldi	r22, 0x0A	; 10
 1a8:	70 e0       	ldi	r23, 0x00	; 0
 1aa:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__udivmodhi4>
 1ae:	80 5d       	subi	r24, 0xD0	; 208
 1b0:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
value=no/10;
lcd_data(48+value);
 1b4:	c8 01       	movw	r24, r16
 1b6:	6a e0       	ldi	r22, 0x0A	; 10
 1b8:	70 e0       	ldi	r23, 0x00	; 0
 1ba:	0e 94 68 06 	call	0xcd0	; 0xcd0 <__udivmodhi4>
 1be:	86 2f       	mov	r24, r22
 1c0:	80 5d       	subi	r24, 0xD0	; 208
 1c2:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>

lcd_command(0x06);
 1c6:	86 e0       	ldi	r24, 0x06	; 6
 1c8:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
}
 1cc:	1f 91       	pop	r17
 1ce:	0f 91       	pop	r16
 1d0:	08 95       	ret

000001d2 <lcd_string_forward>:

void lcd_string_forward(unsigned char *str)
{
 1d2:	ef 92       	push	r14
 1d4:	ff 92       	push	r15
 1d6:	1f 93       	push	r17
 1d8:	cf 93       	push	r28
 1da:	df 93       	push	r29
 1dc:	ec 01       	movw	r28, r24
 1de:	10 e0       	ldi	r17, 0x00	; 0
 1e0:	70 ea       	ldi	r23, 0xA0	; 160
 1e2:	e7 2e       	mov	r14, r23
 1e4:	7f e0       	ldi	r23, 0x0F	; 15
 1e6:	f7 2e       	mov	r15, r23
 1e8:	06 c0       	rjmp	.+12     	; 0x1f6 <lcd_string_forward+0x24>
char d=0;

while(str[d]!='\0')
{
lcd_data(str[d]);
 1ea:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
d++;
 1ee:	1f 5f       	subi	r17, 0xFF	; 255
 1f0:	c7 01       	movw	r24, r14
 1f2:	01 97       	sbiw	r24, 0x01	; 1
 1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_string_forward+0x20>

void lcd_string_forward(unsigned char *str)
{
char d=0;

while(str[d]!='\0')
 1f6:	fe 01       	movw	r30, r28
 1f8:	e1 0f       	add	r30, r17
 1fa:	f1 1d       	adc	r31, r1
 1fc:	80 81       	ld	r24, Z
 1fe:	88 23       	and	r24, r24
 200:	a1 f7       	brne	.-24     	; 0x1ea <lcd_string_forward+0x18>
{
lcd_data(str[d]);
d++;
_delay_ms(1);
}
}
 202:	df 91       	pop	r29
 204:	cf 91       	pop	r28
 206:	1f 91       	pop	r17
 208:	ff 90       	pop	r15
 20a:	ef 90       	pop	r14
 20c:	08 95       	ret

0000020e <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
 20e:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
 210:	e1 99       	sbic	0x1c, 1	; 28
 212:	fe cf       	rjmp	.-4      	; 0x210 <eeprom_write_byte+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 214:	3f bb       	out	0x1f, r19	; 31
 216:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
 218:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
 21a:	0f b6       	in	r0, 0x3f	; 63
 21c:	f8 94       	cli
 21e:	e2 9a       	sbi	0x1c, 2	; 28
 220:	e1 9a       	sbi	0x1c, 1	; 28
 222:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
 224:	08 95       	ret

00000226 <button>:
int set;
int p=0;
char e=0x030;

int button(char ch)
{
 226:	98 2f       	mov	r25, r24
int z=0;
while((PIND&ch)==0);
 228:	80 b3       	in	r24, 0x10	; 16
 22a:	89 23       	and	r24, r25
 22c:	e9 f3       	breq	.-6      	; 0x228 <button+0x2>
 22e:	20 e0       	ldi	r18, 0x00	; 0
 230:	30 e0       	ldi	r19, 0x00	; 0
 232:	40 e0       	ldi	r20, 0x00	; 0
 234:	50 e0       	ldi	r21, 0x00	; 0
 236:	60 ea       	ldi	r22, 0xA0	; 160
 238:	7f e0       	ldi	r23, 0x0F	; 15
 23a:	fb 01       	movw	r30, r22
 23c:	31 97       	sbiw	r30, 0x01	; 1
 23e:	f1 f7       	brne	.-4      	; 0x23c <button+0x16>
for(int i=0;i<750;i++)
{
_delay_ms(1);
if((PIND&ch)==0)
 240:	80 b3       	in	r24, 0x10	; 16
 242:	89 23       	and	r24, r25
 244:	51 f4       	brne	.+20     	; 0x25a <button+0x34>
{
while((PIND&ch)==0);
 246:	80 b3       	in	r24, 0x10	; 16
 248:	89 23       	and	r24, r25
 24a:	e9 f3       	breq	.-6      	; 0x246 <button+0x20>
z++;
 24c:	2f 5f       	subi	r18, 0xFF	; 255
 24e:	3f 4f       	sbci	r19, 0xFF	; 255
if(z==4){z=0;}
 250:	24 30       	cpi	r18, 0x04	; 4
 252:	31 05       	cpc	r19, r1
 254:	11 f4       	brne	.+4      	; 0x25a <button+0x34>
 256:	20 e0       	ldi	r18, 0x00	; 0
 258:	30 e0       	ldi	r19, 0x00	; 0

int button(char ch)
{
int z=0;
while((PIND&ch)==0);
for(int i=0;i<750;i++)
 25a:	4f 5f       	subi	r20, 0xFF	; 255
 25c:	5f 4f       	sbci	r21, 0xFF	; 255
 25e:	82 e0       	ldi	r24, 0x02	; 2
 260:	4e 3e       	cpi	r20, 0xEE	; 238
 262:	58 07       	cpc	r21, r24
 264:	51 f7       	brne	.-44     	; 0x23a <button+0x14>
while((PIND&ch)==0);
z++;
if(z==4){z=0;}
}
}
loc++;
 266:	80 91 e7 00 	lds	r24, 0x00E7
 26a:	8f 5f       	subi	r24, 0xFF	; 255
 26c:	80 93 e7 00 	sts	0x00E7, r24
return z;
}
 270:	c9 01       	movw	r24, r18
 272:	08 95       	ret

00000274 <passinput>:


void passinput()
{
 274:	ef 92       	push	r14
 276:	ff 92       	push	r15
 278:	0f 93       	push	r16
 27a:	1f 93       	push	r17
 27c:	cf 93       	push	r28
 27e:	df 93       	push	r29
 280:	80 e1       	ldi	r24, 0x10	; 16
 282:	97 e2       	ldi	r25, 0x27	; 39
 284:	20 e9       	ldi	r18, 0x90	; 144
 286:	31 e0       	ldi	r19, 0x01	; 1
 288:	f9 01       	movw	r30, r18
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	f1 f7       	brne	.-4      	; 0x28a <passinput+0x16>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 28e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 290:	d9 f7       	brne	.-10     	; 0x288 <passinput+0x14>
_delay_ms(1000);
lcd_command(0x01);
 292:	81 e0       	ldi	r24, 0x01	; 1
 294:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 298:	80 e8       	ldi	r24, 0x80	; 128
 29a:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
c=0;
 29e:	10 92 eb 00 	sts	0x00EB, r1
 2a2:	10 92 ea 00 	sts	0x00EA, r1
while(1)
{
z=0;
lcd_command(loc);
//	1st row
PORTD=0xef;
 2a6:	ff ee       	ldi	r31, 0xEF	; 239
 2a8:	ef 2e       	mov	r14, r31
 2aa:	c0 e4       	ldi	r28, 0x40	; 64
 2ac:	dc e9       	ldi	r29, 0x9C	; 156
lcd_command(loc);
lcd_command(0x06);
}

//	2nd row
PORTD=0xdf;
 2ae:	1f ed       	ldi	r17, 0xDF	; 223
break;
}


//	3rd row
PORTD=0xbf;
 2b0:	0f eb       	ldi	r16, 0xBF	; 191
}



//	4th row
PORTD=0x7f;
 2b2:	ef e7       	ldi	r30, 0x7F	; 127
 2b4:	fe 2e       	mov	r15, r30
lcd_command(0x01);
lcd_command(0x80);
c=0;
while(1)
{
z=0;
 2b6:	10 92 ed 00 	sts	0x00ED, r1
 2ba:	10 92 ec 00 	sts	0x00EC, r1
lcd_command(loc);
 2be:	80 91 e7 00 	lds	r24, 0x00E7
 2c2:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
//	1st row
PORTD=0xef;
 2c6:	e2 ba       	out	0x12, r14	; 18
 2c8:	ce 01       	movw	r24, r28
 2ca:	01 97       	sbiw	r24, 0x01	; 1
 2cc:	f1 f7       	brne	.-4      	; 0x2ca <passinput+0x56>
_delay_ms(10);
if((PIND&0x01)==0)
 2ce:	80 99       	sbic	0x10, 0	; 16
 2d0:	29 c0       	rjmp	.+82     	; 0x324 <passinput+0xb0>
{
z=button(0x01);
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	0e 94 13 01 	call	0x226	; 0x226 <button>
 2d8:	90 93 ed 00 	sts	0x00ED, r25
 2dc:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 2e0:	83 30       	cpi	r24, 0x03	; 3
 2e2:	91 05       	cpc	r25, r1
 2e4:	61 f4       	brne	.+24     	; 0x2fe <passinput+0x8a>
{
lcd_data(49);
 2e6:	81 e3       	ldi	r24, 0x31	; 49
 2e8:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=49;
 2ec:	80 91 ea 00 	lds	r24, 0x00EA
 2f0:	90 91 eb 00 	lds	r25, 0x00EB
 2f4:	fc 01       	movw	r30, r24
 2f6:	ee 5f       	subi	r30, 0xFE	; 254
 2f8:	fe 4f       	sbci	r31, 0xFE	; 254
 2fa:	21 e3       	ldi	r18, 0x31	; 49
 2fc:	0d c0       	rjmp	.+26     	; 0x318 <passinput+0xa4>
c++;
}
else 
{
lcd_data(65+z);
 2fe:	8f 5b       	subi	r24, 0xBF	; 191
 300:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=65+z;
 304:	80 91 ea 00 	lds	r24, 0x00EA
 308:	90 91 eb 00 	lds	r25, 0x00EB
 30c:	fc 01       	movw	r30, r24
 30e:	ee 5f       	subi	r30, 0xFE	; 254
 310:	fe 4f       	sbci	r31, 0xFE	; 254
 312:	20 91 ec 00 	lds	r18, 0x00EC
 316:	2f 5b       	subi	r18, 0xBF	; 191
 318:	20 83       	st	Z, r18
c++;
 31a:	01 96       	adiw	r24, 0x01	; 1
 31c:	90 93 eb 00 	sts	0x00EB, r25
 320:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x02)==0)
 324:	81 99       	sbic	0x10, 1	; 16
 326:	29 c0       	rjmp	.+82     	; 0x37a <passinput+0x106>
{
z=button(0x02);
 328:	82 e0       	ldi	r24, 0x02	; 2
 32a:	0e 94 13 01 	call	0x226	; 0x226 <button>
 32e:	90 93 ed 00 	sts	0x00ED, r25
 332:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 336:	83 30       	cpi	r24, 0x03	; 3
 338:	91 05       	cpc	r25, r1
 33a:	61 f4       	brne	.+24     	; 0x354 <passinput+0xe0>
{
lcd_data(50);
 33c:	82 e3       	ldi	r24, 0x32	; 50
 33e:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=50;
 342:	80 91 ea 00 	lds	r24, 0x00EA
 346:	90 91 eb 00 	lds	r25, 0x00EB
 34a:	fc 01       	movw	r30, r24
 34c:	ee 5f       	subi	r30, 0xFE	; 254
 34e:	fe 4f       	sbci	r31, 0xFE	; 254
 350:	22 e3       	ldi	r18, 0x32	; 50
 352:	0d c0       	rjmp	.+26     	; 0x36e <passinput+0xfa>
c++;
}
else 
{
lcd_data(68+z);
 354:	8c 5b       	subi	r24, 0xBC	; 188
 356:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=68+z;
 35a:	80 91 ea 00 	lds	r24, 0x00EA
 35e:	90 91 eb 00 	lds	r25, 0x00EB
 362:	fc 01       	movw	r30, r24
 364:	ee 5f       	subi	r30, 0xFE	; 254
 366:	fe 4f       	sbci	r31, 0xFE	; 254
 368:	20 91 ec 00 	lds	r18, 0x00EC
 36c:	2c 5b       	subi	r18, 0xBC	; 188
 36e:	20 83       	st	Z, r18
c++;
 370:	01 96       	adiw	r24, 0x01	; 1
 372:	90 93 eb 00 	sts	0x00EB, r25
 376:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x04)==0)
 37a:	82 99       	sbic	0x10, 2	; 16
 37c:	29 c0       	rjmp	.+82     	; 0x3d0 <passinput+0x15c>
{
z=button(0x04);
 37e:	84 e0       	ldi	r24, 0x04	; 4
 380:	0e 94 13 01 	call	0x226	; 0x226 <button>
 384:	90 93 ed 00 	sts	0x00ED, r25
 388:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 38c:	83 30       	cpi	r24, 0x03	; 3
 38e:	91 05       	cpc	r25, r1
 390:	61 f4       	brne	.+24     	; 0x3aa <passinput+0x136>
{
lcd_data(51);
 392:	83 e3       	ldi	r24, 0x33	; 51
 394:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=51;
 398:	80 91 ea 00 	lds	r24, 0x00EA
 39c:	90 91 eb 00 	lds	r25, 0x00EB
 3a0:	fc 01       	movw	r30, r24
 3a2:	ee 5f       	subi	r30, 0xFE	; 254
 3a4:	fe 4f       	sbci	r31, 0xFE	; 254
 3a6:	23 e3       	ldi	r18, 0x33	; 51
 3a8:	0d c0       	rjmp	.+26     	; 0x3c4 <passinput+0x150>
c++;
}
else 
{
lcd_data(71+z);
 3aa:	89 5b       	subi	r24, 0xB9	; 185
 3ac:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=71+z;
 3b0:	80 91 ea 00 	lds	r24, 0x00EA
 3b4:	90 91 eb 00 	lds	r25, 0x00EB
 3b8:	fc 01       	movw	r30, r24
 3ba:	ee 5f       	subi	r30, 0xFE	; 254
 3bc:	fe 4f       	sbci	r31, 0xFE	; 254
 3be:	20 91 ec 00 	lds	r18, 0x00EC
 3c2:	29 5b       	subi	r18, 0xB9	; 185
 3c4:	20 83       	st	Z, r18
c++;
 3c6:	01 96       	adiw	r24, 0x01	; 1
 3c8:	90 93 eb 00 	sts	0x00EB, r25
 3cc:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x08)==0)
 3d0:	83 99       	sbic	0x10, 3	; 16
 3d2:	22 c0       	rjmp	.+68     	; 0x418 <passinput+0x1a4>
{
while((PIND&0x08)==0);
 3d4:	83 9b       	sbis	0x10, 3	; 16
 3d6:	fe cf       	rjmp	.-4      	; 0x3d4 <passinput+0x160>
lcd_command(0x04);
 3d8:	84 e0       	ldi	r24, 0x04	; 4
 3da:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
loc--;
 3de:	80 91 e7 00 	lds	r24, 0x00E7
 3e2:	81 50       	subi	r24, 0x01	; 1
 3e4:	80 93 e7 00 	sts	0x00E7, r24
c--;
 3e8:	e0 91 ea 00 	lds	r30, 0x00EA
 3ec:	f0 91 eb 00 	lds	r31, 0x00EB
 3f0:	31 97       	sbiw	r30, 0x01	; 1
 3f2:	f0 93 eb 00 	sts	0x00EB, r31
 3f6:	e0 93 ea 00 	sts	0x00EA, r30
A[c]='\0';
 3fa:	ee 5f       	subi	r30, 0xFE	; 254
 3fc:	fe 4f       	sbci	r31, 0xFE	; 254
 3fe:	10 82       	st	Z, r1
lcd_command(loc);
 400:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_data(' ');
 404:	80 e2       	ldi	r24, 0x20	; 32
 406:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
lcd_command(loc);
 40a:	80 91 e7 00 	lds	r24, 0x00E7
 40e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x06);
 412:	86 e0       	ldi	r24, 0x06	; 6
 414:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
}

//	2nd row
PORTD=0xdf;
 418:	12 bb       	out	0x12, r17	; 18
 41a:	ce 01       	movw	r24, r28
 41c:	01 97       	sbiw	r24, 0x01	; 1
 41e:	f1 f7       	brne	.-4      	; 0x41c <passinput+0x1a8>
_delay_ms(10);
if((PIND&0x01)==0)
 420:	80 99       	sbic	0x10, 0	; 16
 422:	29 c0       	rjmp	.+82     	; 0x476 <__stack+0x17>
{
z=button(0x01);
 424:	81 e0       	ldi	r24, 0x01	; 1
 426:	0e 94 13 01 	call	0x226	; 0x226 <button>
 42a:	90 93 ed 00 	sts	0x00ED, r25
 42e:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 432:	83 30       	cpi	r24, 0x03	; 3
 434:	91 05       	cpc	r25, r1
 436:	61 f4       	brne	.+24     	; 0x450 <passinput+0x1dc>
{
lcd_data(52);
 438:	84 e3       	ldi	r24, 0x34	; 52
 43a:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=52;
 43e:	80 91 ea 00 	lds	r24, 0x00EA
 442:	90 91 eb 00 	lds	r25, 0x00EB
 446:	fc 01       	movw	r30, r24
 448:	ee 5f       	subi	r30, 0xFE	; 254
 44a:	fe 4f       	sbci	r31, 0xFE	; 254
 44c:	24 e3       	ldi	r18, 0x34	; 52
 44e:	0d c0       	rjmp	.+26     	; 0x46a <__stack+0xb>
c++;
}
else 
{
lcd_data(74+z);
 450:	86 5b       	subi	r24, 0xB6	; 182
 452:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=74+z;
 456:	80 91 ea 00 	lds	r24, 0x00EA
 45a:	90 91 eb 00 	lds	r25, 0x00EB
 45e:	fc 01       	movw	r30, r24
 460:	ee 5f       	subi	r30, 0xFE	; 254
 462:	fe 4f       	sbci	r31, 0xFE	; 254
 464:	20 91 ec 00 	lds	r18, 0x00EC
 468:	26 5b       	subi	r18, 0xB6	; 182
 46a:	20 83       	st	Z, r18
c++;
 46c:	01 96       	adiw	r24, 0x01	; 1
 46e:	90 93 eb 00 	sts	0x00EB, r25
 472:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x02)==0)
 476:	81 99       	sbic	0x10, 1	; 16
 478:	29 c0       	rjmp	.+82     	; 0x4cc <__stack+0x6d>
{
z=button(0x02);
 47a:	82 e0       	ldi	r24, 0x02	; 2
 47c:	0e 94 13 01 	call	0x226	; 0x226 <button>
 480:	90 93 ed 00 	sts	0x00ED, r25
 484:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 488:	83 30       	cpi	r24, 0x03	; 3
 48a:	91 05       	cpc	r25, r1
 48c:	61 f4       	brne	.+24     	; 0x4a6 <__stack+0x47>
{
lcd_data(53);
 48e:	85 e3       	ldi	r24, 0x35	; 53
 490:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=53;
 494:	80 91 ea 00 	lds	r24, 0x00EA
 498:	90 91 eb 00 	lds	r25, 0x00EB
 49c:	fc 01       	movw	r30, r24
 49e:	ee 5f       	subi	r30, 0xFE	; 254
 4a0:	fe 4f       	sbci	r31, 0xFE	; 254
 4a2:	25 e3       	ldi	r18, 0x35	; 53
 4a4:	0d c0       	rjmp	.+26     	; 0x4c0 <__stack+0x61>
c++;
}
else 
{
lcd_data(77+z);
 4a6:	83 5b       	subi	r24, 0xB3	; 179
 4a8:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=77+z;
 4ac:	80 91 ea 00 	lds	r24, 0x00EA
 4b0:	90 91 eb 00 	lds	r25, 0x00EB
 4b4:	fc 01       	movw	r30, r24
 4b6:	ee 5f       	subi	r30, 0xFE	; 254
 4b8:	fe 4f       	sbci	r31, 0xFE	; 254
 4ba:	20 91 ec 00 	lds	r18, 0x00EC
 4be:	23 5b       	subi	r18, 0xB3	; 179
 4c0:	20 83       	st	Z, r18
c++;
 4c2:	01 96       	adiw	r24, 0x01	; 1
 4c4:	90 93 eb 00 	sts	0x00EB, r25
 4c8:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x04)==0)
 4cc:	82 99       	sbic	0x10, 2	; 16
 4ce:	29 c0       	rjmp	.+82     	; 0x522 <__stack+0xc3>
{
z=button(0x04);
 4d0:	84 e0       	ldi	r24, 0x04	; 4
 4d2:	0e 94 13 01 	call	0x226	; 0x226 <button>
 4d6:	90 93 ed 00 	sts	0x00ED, r25
 4da:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 4de:	83 30       	cpi	r24, 0x03	; 3
 4e0:	91 05       	cpc	r25, r1
 4e2:	61 f4       	brne	.+24     	; 0x4fc <__stack+0x9d>
{
lcd_data(54);
 4e4:	86 e3       	ldi	r24, 0x36	; 54
 4e6:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=54;
 4ea:	80 91 ea 00 	lds	r24, 0x00EA
 4ee:	90 91 eb 00 	lds	r25, 0x00EB
 4f2:	fc 01       	movw	r30, r24
 4f4:	ee 5f       	subi	r30, 0xFE	; 254
 4f6:	fe 4f       	sbci	r31, 0xFE	; 254
 4f8:	26 e3       	ldi	r18, 0x36	; 54
 4fa:	0d c0       	rjmp	.+26     	; 0x516 <__stack+0xb7>
c++;
}
else 
{
lcd_data(80+z);
 4fc:	80 5b       	subi	r24, 0xB0	; 176
 4fe:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=80+z;
 502:	80 91 ea 00 	lds	r24, 0x00EA
 506:	90 91 eb 00 	lds	r25, 0x00EB
 50a:	fc 01       	movw	r30, r24
 50c:	ee 5f       	subi	r30, 0xFE	; 254
 50e:	fe 4f       	sbci	r31, 0xFE	; 254
 510:	20 91 ec 00 	lds	r18, 0x00EC
 514:	20 5b       	subi	r18, 0xB0	; 176
 516:	20 83       	st	Z, r18
c++;
 518:	01 96       	adiw	r24, 0x01	; 1
 51a:	90 93 eb 00 	sts	0x00EB, r25
 51e:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x08)==0)
 522:	83 99       	sbic	0x10, 3	; 16
 524:	05 c0       	rjmp	.+10     	; 0x530 <__stack+0xd1>
{
while((PIND&0x08)==0);
 526:	83 9b       	sbis	0x10, 3	; 16
 528:	fe cf       	rjmp	.-4      	; 0x526 <__stack+0xc7>
choice=1;
 52a:	81 e0       	ldi	r24, 0x01	; 1
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	b8 c0       	rjmp	.+368    	; 0x6a0 <__stack+0x241>
break;
}


//	3rd row
PORTD=0xbf;
 530:	02 bb       	out	0x12, r16	; 18
 532:	ce 01       	movw	r24, r28
 534:	01 97       	sbiw	r24, 0x01	; 1
 536:	f1 f7       	brne	.-4      	; 0x534 <__stack+0xd5>
_delay_ms(10);

if((PIND&0x01)==0)
 538:	80 99       	sbic	0x10, 0	; 16
 53a:	29 c0       	rjmp	.+82     	; 0x58e <__stack+0x12f>
{
z=button(0x01);
 53c:	81 e0       	ldi	r24, 0x01	; 1
 53e:	0e 94 13 01 	call	0x226	; 0x226 <button>
 542:	90 93 ed 00 	sts	0x00ED, r25
 546:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 54a:	83 30       	cpi	r24, 0x03	; 3
 54c:	91 05       	cpc	r25, r1
 54e:	61 f4       	brne	.+24     	; 0x568 <__stack+0x109>
{
lcd_data(55);
 550:	87 e3       	ldi	r24, 0x37	; 55
 552:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=55;
 556:	80 91 ea 00 	lds	r24, 0x00EA
 55a:	90 91 eb 00 	lds	r25, 0x00EB
 55e:	fc 01       	movw	r30, r24
 560:	ee 5f       	subi	r30, 0xFE	; 254
 562:	fe 4f       	sbci	r31, 0xFE	; 254
 564:	27 e3       	ldi	r18, 0x37	; 55
 566:	0d c0       	rjmp	.+26     	; 0x582 <__stack+0x123>
c++;
}
else 
{
lcd_data(83+z);
 568:	8d 5a       	subi	r24, 0xAD	; 173
 56a:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=83+z;
 56e:	80 91 ea 00 	lds	r24, 0x00EA
 572:	90 91 eb 00 	lds	r25, 0x00EB
 576:	fc 01       	movw	r30, r24
 578:	ee 5f       	subi	r30, 0xFE	; 254
 57a:	fe 4f       	sbci	r31, 0xFE	; 254
 57c:	20 91 ec 00 	lds	r18, 0x00EC
 580:	2d 5a       	subi	r18, 0xAD	; 173
 582:	20 83       	st	Z, r18
c++;
 584:	01 96       	adiw	r24, 0x01	; 1
 586:	90 93 eb 00 	sts	0x00EB, r25
 58a:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x02)==0)
 58e:	81 99       	sbic	0x10, 1	; 16
 590:	29 c0       	rjmp	.+82     	; 0x5e4 <__stack+0x185>
{
z=button(0x02);
 592:	82 e0       	ldi	r24, 0x02	; 2
 594:	0e 94 13 01 	call	0x226	; 0x226 <button>
 598:	90 93 ed 00 	sts	0x00ED, r25
 59c:	80 93 ec 00 	sts	0x00EC, r24
if(z==3)
 5a0:	83 30       	cpi	r24, 0x03	; 3
 5a2:	91 05       	cpc	r25, r1
 5a4:	61 f4       	brne	.+24     	; 0x5be <__stack+0x15f>
{
lcd_data(56);
 5a6:	88 e3       	ldi	r24, 0x38	; 56
 5a8:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=56;
 5ac:	80 91 ea 00 	lds	r24, 0x00EA
 5b0:	90 91 eb 00 	lds	r25, 0x00EB
 5b4:	fc 01       	movw	r30, r24
 5b6:	ee 5f       	subi	r30, 0xFE	; 254
 5b8:	fe 4f       	sbci	r31, 0xFE	; 254
 5ba:	28 e3       	ldi	r18, 0x38	; 56
 5bc:	0d c0       	rjmp	.+26     	; 0x5d8 <__stack+0x179>
c++;
}
else 
{
lcd_data(86+z);
 5be:	8a 5a       	subi	r24, 0xAA	; 170
 5c0:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=86+z;
 5c4:	80 91 ea 00 	lds	r24, 0x00EA
 5c8:	90 91 eb 00 	lds	r25, 0x00EB
 5cc:	fc 01       	movw	r30, r24
 5ce:	ee 5f       	subi	r30, 0xFE	; 254
 5d0:	fe 4f       	sbci	r31, 0xFE	; 254
 5d2:	20 91 ec 00 	lds	r18, 0x00EC
 5d6:	2a 5a       	subi	r18, 0xAA	; 170
 5d8:	20 83       	st	Z, r18
c++;
 5da:	01 96       	adiw	r24, 0x01	; 1
 5dc:	90 93 eb 00 	sts	0x00EB, r25
 5e0:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x04)==0)
 5e4:	82 99       	sbic	0x10, 2	; 16
 5e6:	29 c0       	rjmp	.+82     	; 0x63a <__stack+0x1db>
{
z=button(0x04);
 5e8:	84 e0       	ldi	r24, 0x04	; 4
 5ea:	0e 94 13 01 	call	0x226	; 0x226 <button>
 5ee:	90 93 ed 00 	sts	0x00ED, r25
 5f2:	80 93 ec 00 	sts	0x00EC, r24
if(z==2)
 5f6:	82 30       	cpi	r24, 0x02	; 2
 5f8:	91 05       	cpc	r25, r1
 5fa:	61 f4       	brne	.+24     	; 0x614 <__stack+0x1b5>
{
lcd_data(57);
 5fc:	89 e3       	ldi	r24, 0x39	; 57
 5fe:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=57;
 602:	80 91 ea 00 	lds	r24, 0x00EA
 606:	90 91 eb 00 	lds	r25, 0x00EB
 60a:	fc 01       	movw	r30, r24
 60c:	ee 5f       	subi	r30, 0xFE	; 254
 60e:	fe 4f       	sbci	r31, 0xFE	; 254
 610:	29 e3       	ldi	r18, 0x39	; 57
 612:	0d c0       	rjmp	.+26     	; 0x62e <__stack+0x1cf>
c++;
}
else 
{
lcd_data(89+z);
 614:	87 5a       	subi	r24, 0xA7	; 167
 616:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
A[c]=89+z;
 61a:	80 91 ea 00 	lds	r24, 0x00EA
 61e:	90 91 eb 00 	lds	r25, 0x00EB
 622:	fc 01       	movw	r30, r24
 624:	ee 5f       	subi	r30, 0xFE	; 254
 626:	fe 4f       	sbci	r31, 0xFE	; 254
 628:	20 91 ec 00 	lds	r18, 0x00EC
 62c:	27 5a       	subi	r18, 0xA7	; 167
 62e:	20 83       	st	Z, r18
c++;
 630:	01 96       	adiw	r24, 0x01	; 1
 632:	90 93 eb 00 	sts	0x00EB, r25
 636:	80 93 ea 00 	sts	0x00EA, r24
}
}

if((PIND&0x08)==0)
 63a:	83 99       	sbic	0x10, 3	; 16
 63c:	05 c0       	rjmp	.+10     	; 0x648 <__stack+0x1e9>
{
while((PIND&0x08)==0);
 63e:	83 9b       	sbis	0x10, 3	; 16
 640:	fe cf       	rjmp	.-4      	; 0x63e <__stack+0x1df>
choice=3;
 642:	83 e0       	ldi	r24, 0x03	; 3
 644:	90 e0       	ldi	r25, 0x00	; 0
 646:	2c c0       	rjmp	.+88     	; 0x6a0 <__stack+0x241>
}



//	4th row
PORTD=0x7f;
 648:	f2 ba       	out	0x12, r15	; 18
 64a:	ce 01       	movw	r24, r28
 64c:	01 97       	sbiw	r24, 0x01	; 1
 64e:	f1 f7       	brne	.-4      	; 0x64c <__stack+0x1ed>
_delay_ms(10);
if((PIND&0x01)==0)
 650:	80 99       	sbic	0x10, 0	; 16
 652:	0a c0       	rjmp	.+20     	; 0x668 <__stack+0x209>
{
z=button(0x01);
 654:	81 e0       	ldi	r24, 0x01	; 1
 656:	0e 94 13 01 	call	0x226	; 0x226 <button>
 65a:	90 93 ed 00 	sts	0x00ED, r25
 65e:	80 93 ec 00 	sts	0x00EC, r24
lcd_data('*');
 662:	8a e2       	ldi	r24, 0x2A	; 42
 664:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
}
if((PIND&0x02)==0)
 668:	81 99       	sbic	0x10, 1	; 16
 66a:	0a c0       	rjmp	.+20     	; 0x680 <__stack+0x221>
{
z=button(0x02);
 66c:	82 e0       	ldi	r24, 0x02	; 2
 66e:	0e 94 13 01 	call	0x226	; 0x226 <button>
 672:	90 93 ed 00 	sts	0x00ED, r25
 676:	80 93 ec 00 	sts	0x00EC, r24
lcd_data(48);
 67a:	80 e3       	ldi	r24, 0x30	; 48
 67c:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
}
if((PIND&0x04)==0)
 680:	82 99       	sbic	0x10, 2	; 16
 682:	0a c0       	rjmp	.+20     	; 0x698 <__stack+0x239>
{
z=button(0x04);
 684:	84 e0       	ldi	r24, 0x04	; 4
 686:	0e 94 13 01 	call	0x226	; 0x226 <button>
 68a:	90 93 ed 00 	sts	0x00ED, r25
 68e:	80 93 ec 00 	sts	0x00EC, r24
lcd_data('#');
 692:	83 e2       	ldi	r24, 0x23	; 35
 694:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
}
if((PIND&0x08)==0)
 698:	83 99       	sbic	0x10, 3	; 16
 69a:	0d ce       	rjmp	.-998    	; 0x2b6 <passinput+0x42>
{
choice=4;
 69c:	84 e0       	ldi	r24, 0x04	; 4
 69e:	90 e0       	ldi	r25, 0x00	; 0
 6a0:	90 93 ef 00 	sts	0x00EF, r25
 6a4:	80 93 ee 00 	sts	0x00EE, r24
break;
}

}
stop: 
lcd_command(0x01);
 6a8:	81 e0       	ldi	r24, 0x01	; 1
 6aa:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
}
 6ae:	df 91       	pop	r29
 6b0:	cf 91       	pop	r28
 6b2:	1f 91       	pop	r17
 6b4:	0f 91       	pop	r16
 6b6:	ff 90       	pop	r15
 6b8:	ef 90       	pop	r14
 6ba:	08 95       	ret

000006bc <lcd_string_back>:

void lcd_string_back(unsigned char *str)
{
 6bc:	ef 92       	push	r14
 6be:	ff 92       	push	r15
 6c0:	1f 93       	push	r17
 6c2:	cf 93       	push	r28
 6c4:	df 93       	push	r29
 6c6:	ec 01       	movw	r28, r24
char d=strlen(str)-1;
 6c8:	dc 01       	movw	r26, r24
 6ca:	0d 90       	ld	r0, X+
 6cc:	00 20       	and	r0, r0
 6ce:	e9 f7       	brne	.-6      	; 0x6ca <lcd_string_back+0xe>
 6d0:	1a 2f       	mov	r17, r26
 6d2:	18 1b       	sub	r17, r24
 6d4:	12 50       	subi	r17, 0x02	; 2
 6d6:	a0 ea       	ldi	r26, 0xA0	; 160
 6d8:	ea 2e       	mov	r14, r26
 6da:	af e0       	ldi	r26, 0x0F	; 15
 6dc:	fa 2e       	mov	r15, r26
 6de:	0a c0       	rjmp	.+20     	; 0x6f4 <lcd_string_back+0x38>

while(d>0)
{
lcd_data(str[d]);
 6e0:	fe 01       	movw	r30, r28
 6e2:	e1 0f       	add	r30, r17
 6e4:	f1 1d       	adc	r31, r1
 6e6:	80 81       	ld	r24, Z
 6e8:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
d--;
 6ec:	11 50       	subi	r17, 0x01	; 1
 6ee:	c7 01       	movw	r24, r14
 6f0:	01 97       	sbiw	r24, 0x01	; 1
 6f2:	f1 f7       	brne	.-4      	; 0x6f0 <lcd_string_back+0x34>

void lcd_string_back(unsigned char *str)
{
char d=strlen(str)-1;

while(d>0)
 6f4:	11 23       	and	r17, r17
 6f6:	a1 f7       	brne	.-24     	; 0x6e0 <lcd_string_back+0x24>
{
lcd_data(str[d]);
d--;
_delay_ms(1);
}
}
 6f8:	df 91       	pop	r29
 6fa:	cf 91       	pop	r28
 6fc:	1f 91       	pop	r17
 6fe:	ff 90       	pop	r15
 700:	ef 90       	pop	r14
 702:	08 95       	ret

00000704 <main>:


int main()
{
 704:	5f 92       	push	r5
 706:	6f 92       	push	r6
 708:	7f 92       	push	r7
 70a:	8f 92       	push	r8
 70c:	9f 92       	push	r9
 70e:	af 92       	push	r10
 710:	bf 92       	push	r11
 712:	cf 92       	push	r12
 714:	df 92       	push	r13
 716:	ef 92       	push	r14
 718:	ff 92       	push	r15
 71a:	0f 93       	push	r16
 71c:	1f 93       	push	r17
 71e:	cf 93       	push	r28
 720:	df 93       	push	r29
DDRD=0xf0;
 722:	80 ef       	ldi	r24, 0xF0	; 240
 724:	81 bb       	out	0x11, r24	; 17
DDRC=255;
 726:	1f ef       	ldi	r17, 0xFF	; 255
 728:	14 bb       	out	0x14, r17	; 20
lcd_init();
 72a:	0e 94 62 00 	call	0xc4	; 0xc4 <lcd_init>

DDRB=255;
 72e:	17 bb       	out	0x17, r17	; 23
PORTB=0;
 730:	18 ba       	out	0x18, r1	; 24
 732:	c0 e9       	ldi	r28, 0x90	; 144
 734:	d1 e0       	ldi	r29, 0x01	; 1
{
    do {} while (!eeprom_is_ready ());
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 736:	32 e7       	ldi	r19, 0x72	; 114
 738:	e3 2e       	mov	r14, r19
 73a:	f1 2c       	mov	r15, r1
lcd_command(0x80);
passinput();
set=eeprom_read_byte(0x072);
if(set!=1)
{
choice=2;
 73c:	22 e0       	ldi	r18, 0x02	; 2
 73e:	82 2e       	mov	r8, r18
 740:	91 2c       	mov	r9, r1
al=strlen(A);
 742:	92 e0       	ldi	r25, 0x02	; 2
 744:	69 2e       	mov	r6, r25
 746:	91 e0       	ldi	r25, 0x01	; 1
 748:	79 2e       	mov	r7, r25
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 74a:	00 e7       	ldi	r16, 0x70	; 112
 74c:	10 e0       	ldi	r17, 0x00	; 0
lcd_command(0x01);
lcd_command(0x80);
lcd_string("password set");


set=1;
 74e:	81 e0       	ldi	r24, 0x01	; 1
 750:	c8 2e       	mov	r12, r24
 752:	d1 2c       	mov	r13, r1
}
}
else 
{
lcd_string("Wrong Password");
choice=4;}
 754:	b4 e0       	ldi	r27, 0x04	; 4
 756:	ab 2e       	mov	r10, r27
 758:	b1 2c       	mov	r11, r1
{
_delay_ms(1000);
lcd_command(0x01);
lcd_command(0x80);
lcd_string("Password Matched");
PORTB=255;
 75a:	55 24       	eor	r5, r5
 75c:	5a 94       	dec	r5
DDRB=255;
PORTB=0;

while(1)
{
passinput();
 75e:	0e 94 3a 01 	call	0x274	; 0x274 <passinput>
if(choice==1)
 762:	80 91 ee 00 	lds	r24, 0x00EE
 766:	90 91 ef 00 	lds	r25, 0x00EF
 76a:	01 97       	sbiw	r24, 0x01	; 1
 76c:	09 f0       	breq	.+2      	; 0x770 <main+0x6c>
 76e:	ea c0       	rjmp	.+468    	; 0x944 <main+0x240>
{
lcd_command(0x01);
 770:	81 e0       	ldi	r24, 0x01	; 1
 772:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 776:	80 e8       	ldi	r24, 0x80	; 128
 778:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
 77c:	80 e1       	ldi	r24, 0x10	; 16
 77e:	97 e2       	ldi	r25, 0x27	; 39
 780:	fe 01       	movw	r30, r28
 782:	31 97       	sbiw	r30, 0x01	; 1
 784:	f1 f7       	brne	.-4      	; 0x782 <main+0x7e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 786:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 788:	d9 f7       	brne	.-10     	; 0x780 <main+0x7c>
_delay_ms(1000);
lcd_string("Enter Password");
 78a:	80 e6       	ldi	r24, 0x60	; 96
 78c:	90 e0       	ldi	r25, 0x00	; 0
 78e:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 792:	80 e1       	ldi	r24, 0x10	; 16
 794:	97 e2       	ldi	r25, 0x27	; 39
 796:	fe 01       	movw	r30, r28
 798:	31 97       	sbiw	r30, 0x01	; 1
 79a:	f1 f7       	brne	.-4      	; 0x798 <main+0x94>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 79c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 79e:	d9 f7       	brne	.-10     	; 0x796 <main+0x92>
_delay_ms(1000);
lcd_command(0x01);
 7a0:	81 e0       	ldi	r24, 0x01	; 1
 7a2:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 7a6:	80 e8       	ldi	r24, 0x80	; 128
 7a8:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
passinput();
 7ac:	0e 94 3a 01 	call	0x274	; 0x274 <passinput>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 7b0:	e1 99       	sbic	0x1c, 1	; 28
 7b2:	fe cf       	rjmp	.-4      	; 0x7b0 <main+0xac>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 7b4:	ff ba       	out	0x1f, r15	; 31
 7b6:	ee ba       	out	0x1e, r14	; 30
#endif
    EECR |= (1 << EERE);
 7b8:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
 7ba:	8d b3       	in	r24, 0x1d	; 29
set=eeprom_read_byte(0x072);
 7bc:	90 e0       	ldi	r25, 0x00	; 0
 7be:	90 93 2b 01 	sts	0x012B, r25
 7c2:	80 93 2a 01 	sts	0x012A, r24
if(set!=1)
 7c6:	01 97       	sbiw	r24, 0x01	; 1
 7c8:	09 f4       	brne	.+2      	; 0x7cc <main+0xc8>
 7ca:	bc c0       	rjmp	.+376    	; 0x944 <main+0x240>
{
choice=2;
 7cc:	90 92 ef 00 	sts	0x00EF, r9
 7d0:	80 92 ee 00 	sts	0x00EE, r8
al=strlen(A);
 7d4:	f3 01       	movw	r30, r6
 7d6:	01 90       	ld	r0, Z+
 7d8:	00 20       	and	r0, r0
 7da:	e9 f7       	brne	.-6      	; 0x7d6 <main+0xd2>
 7dc:	31 97       	sbiw	r30, 0x01	; 1
 7de:	e2 50       	subi	r30, 0x02	; 2
 7e0:	f1 40       	sbci	r31, 0x01	; 1
 7e2:	f0 93 27 01 	sts	0x0127, r31
 7e6:	e0 93 26 01 	sts	0x0126, r30
    \note The argument order is mismatch with common functions like strcpy().
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
 7ea:	27 e0       	ldi	r18, 0x07	; 7
 7ec:	31 e0       	ldi	r19, 0x01	; 1
 7ee:	af 01       	movw	r20, r30
 7f0:	60 e6       	ldi	r22, 0x60	; 96
 7f2:	70 e0       	ldi	r23, 0x00	; 0
 7f4:	82 e0       	ldi	r24, 0x02	; 2
 7f6:	91 e0       	ldi	r25, 0x01	; 1
 7f8:	0e 94 4c 06 	call	0xc98	; 0xc98 <__eewr_block>
eeprom_write_block(0x060,A,al);
eeprom_write_byte(0x070,al);
 7fc:	80 91 26 01 	lds	r24, 0x0126
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 800:	e1 99       	sbic	0x1c, 1	; 28
 802:	fe cf       	rjmp	.-4      	; 0x800 <main+0xfc>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 804:	1f bb       	out	0x1f, r17	; 31
 806:	0e bb       	out	0x1e, r16	; 30
#endif
    EEDR = __value;
 808:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
 80a:	0f b6       	in	r0, 0x3f	; 63
 80c:	f8 94       	cli
 80e:	e2 9a       	sbi	0x1c, 2	; 28
 810:	e1 9a       	sbi	0x1c, 1	; 28
 812:	0f be       	out	0x3f, r0	; 63
lcd_command(0x01);
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 81a:	80 e8       	ldi	r24, 0x80	; 128
 81c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string(A);
 820:	82 e0       	ldi	r24, 0x02	; 2
 822:	91 e0       	ldi	r25, 0x01	; 1
 824:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 828:	80 e1       	ldi	r24, 0x10	; 16
 82a:	97 e2       	ldi	r25, 0x27	; 39
 82c:	fe 01       	movw	r30, r28
 82e:	31 97       	sbiw	r30, 0x01	; 1
 830:	f1 f7       	brne	.-4      	; 0x82e <main+0x12a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 832:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 834:	d9 f7       	brne	.-10     	; 0x82c <main+0x128>
_delay_ms(1000);
lcd_command(0x01);
 836:	81 e0       	ldi	r24, 0x01	; 1
 838:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 83c:	80 e8       	ldi	r24, 0x80	; 128
 83e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 842:	e1 99       	sbic	0x1c, 1	; 28
 844:	fe cf       	rjmp	.-4      	; 0x842 <main+0x13e>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 846:	1f bb       	out	0x1f, r17	; 31
 848:	0e bb       	out	0x1e, r16	; 30
#endif
    EECR |= (1 << EERE);
 84a:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
 84c:	8d b3       	in	r24, 0x1d	; 29
int t=0;
t=eeprom_read_byte(0x070);
lcd_number(t);
 84e:	90 e0       	ldi	r25, 0x00	; 0
 850:	0e 94 aa 00 	call	0x154	; 0x154 <lcd_number>
 854:	80 e1       	ldi	r24, 0x10	; 16
 856:	97 e2       	ldi	r25, 0x27	; 39
 858:	fe 01       	movw	r30, r28
 85a:	31 97       	sbiw	r30, 0x01	; 1
 85c:	f1 f7       	brne	.-4      	; 0x85a <main+0x156>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 85e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 860:	d9 f7       	brne	.-10     	; 0x858 <main+0x154>
_delay_ms(1000);

e=0x030;
for(i=0;i<=al;i++)
 862:	60 91 26 01 	lds	r22, 0x0126
 866:	70 91 27 01 	lds	r23, 0x0127
 86a:	a2 e0       	ldi	r26, 0x02	; 2
 86c:	b1 e0       	ldi	r27, 0x01	; 1
 86e:	fd 01       	movw	r30, r26
 870:	40 e3       	ldi	r20, 0x30	; 48
 872:	20 e0       	ldi	r18, 0x00	; 0
 874:	30 e0       	ldi	r19, 0x00	; 0
 876:	11 c0       	rjmp	.+34     	; 0x89a <main+0x196>
{
eeprom_write_byte(e,A[i]);
 878:	50 81       	ld	r21, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 87a:	e1 99       	sbic	0x1c, 1	; 28
 87c:	fe cf       	rjmp	.-4      	; 0x87a <main+0x176>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 87e:	84 2f       	mov	r24, r20
 880:	90 e0       	ldi	r25, 0x00	; 0
 882:	9f bb       	out	0x1f, r25	; 31
 884:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
 886:	5d bb       	out	0x1d, r21	; 29

    __asm__ __volatile__ (
 888:	0f b6       	in	r0, 0x3f	; 63
 88a:	f8 94       	cli
 88c:	e2 9a       	sbi	0x1c, 2	; 28
 88e:	e1 9a       	sbi	0x1c, 1	; 28
 890:	0f be       	out	0x3f, r0	; 63
 892:	4f 5f       	subi	r20, 0xFF	; 255
 894:	2f 5f       	subi	r18, 0xFF	; 255
 896:	3f 4f       	sbci	r19, 0xFF	; 255
 898:	31 96       	adiw	r30, 0x01	; 1
t=eeprom_read_byte(0x070);
lcd_number(t);
_delay_ms(1000);

e=0x030;
for(i=0;i<=al;i++)
 89a:	62 17       	cp	r22, r18
 89c:	73 07       	cpc	r23, r19
 89e:	64 f7       	brge	.-40     	; 0x878 <main+0x174>
 8a0:	e4 e1       	ldi	r30, 0x14	; 20
 8a2:	f1 e0       	ldi	r31, 0x01	; 1
 8a4:	40 e3       	ldi	r20, 0x30	; 48
 8a6:	20 e0       	ldi	r18, 0x00	; 0
 8a8:	30 e0       	ldi	r19, 0x00	; 0
 8aa:	0e c0       	rjmp	.+28     	; 0x8c8 <main+0x1c4>
e++;
}
e=0x030;
for(i=0;i<=al;i++)
{
A[i]='\0';
 8ac:	1c 92       	st	X, r1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 8ae:	e1 99       	sbic	0x1c, 1	; 28
 8b0:	fe cf       	rjmp	.-4      	; 0x8ae <main+0x1aa>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 8b2:	84 2f       	mov	r24, r20
 8b4:	90 e0       	ldi	r25, 0x00	; 0
 8b6:	9f bb       	out	0x1f, r25	; 31
 8b8:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
 8ba:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
 8bc:	8d b3       	in	r24, 0x1d	; 29
B[i]=eeprom_read_byte(e);
 8be:	81 93       	st	Z+, r24
 8c0:	4f 5f       	subi	r20, 0xFF	; 255
 8c2:	2f 5f       	subi	r18, 0xFF	; 255
 8c4:	3f 4f       	sbci	r19, 0xFF	; 255
 8c6:	11 96       	adiw	r26, 0x01	; 1
{
eeprom_write_byte(e,A[i]);
e++;
}
e=0x030;
for(i=0;i<=al;i++)
 8c8:	80 91 26 01 	lds	r24, 0x0126
 8cc:	90 91 27 01 	lds	r25, 0x0127
 8d0:	82 17       	cp	r24, r18
 8d2:	93 07       	cpc	r25, r19
 8d4:	5c f7       	brge	.-42     	; 0x8ac <main+0x1a8>
 8d6:	40 93 e8 00 	sts	0x00E8, r20
 8da:	30 93 25 01 	sts	0x0125, r19
 8de:	20 93 24 01 	sts	0x0124, r18
 8e2:	80 e1       	ldi	r24, 0x10	; 16
 8e4:	97 e2       	ldi	r25, 0x27	; 39
 8e6:	fe 01       	movw	r30, r28
 8e8:	31 97       	sbiw	r30, 0x01	; 1
 8ea:	f1 f7       	brne	.-4      	; 0x8e8 <main+0x1e4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 8ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 8ee:	d9 f7       	brne	.-10     	; 0x8e6 <main+0x1e2>
B[i]=eeprom_read_byte(e);
e++;
}

_delay_ms(1000);
lcd_command(0x01);
 8f0:	81 e0       	ldi	r24, 0x01	; 1
 8f2:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 8f6:	80 e8       	ldi	r24, 0x80	; 128
 8f8:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string(B);
 8fc:	84 e1       	ldi	r24, 0x14	; 20
 8fe:	91 e0       	ldi	r25, 0x01	; 1
 900:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 904:	80 e1       	ldi	r24, 0x10	; 16
 906:	97 e2       	ldi	r25, 0x27	; 39
 908:	fe 01       	movw	r30, r28
 90a:	31 97       	sbiw	r30, 0x01	; 1
 90c:	f1 f7       	brne	.-4      	; 0x90a <main+0x206>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 90e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 910:	d9 f7       	brne	.-10     	; 0x908 <main+0x204>

_delay_ms(1000);
lcd_command(0x01);
 912:	81 e0       	ldi	r24, 0x01	; 1
 914:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 918:	80 e8       	ldi	r24, 0x80	; 128
 91a:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("password set");
 91e:	8f e6       	ldi	r24, 0x6F	; 111
 920:	90 e0       	ldi	r25, 0x00	; 0
 922:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>


set=1;
 926:	d0 92 2b 01 	sts	0x012B, r13
 92a:	c0 92 2a 01 	sts	0x012A, r12
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 92e:	e1 99       	sbic	0x1c, 1	; 28
 930:	fe cf       	rjmp	.-4      	; 0x92e <main+0x22a>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 932:	ff ba       	out	0x1f, r15	; 31
 934:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
 936:	81 e0       	ldi	r24, 0x01	; 1
 938:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
 93a:	0f b6       	in	r0, 0x3f	; 63
 93c:	f8 94       	cli
 93e:	e2 9a       	sbi	0x1c, 2	; 28
 940:	e1 9a       	sbi	0x1c, 1	; 28
 942:	0f be       	out	0x3f, r0	; 63
eeprom_write_byte(0x072,set);
}
}

if(choice==2)
 944:	80 91 ee 00 	lds	r24, 0x00EE
 948:	90 91 ef 00 	lds	r25, 0x00EF
 94c:	02 97       	sbiw	r24, 0x02	; 2
 94e:	01 f5       	brne	.+64     	; 0x990 <main+0x28c>
 950:	80 e1       	ldi	r24, 0x10	; 16
 952:	97 e2       	ldi	r25, 0x27	; 39
 954:	fe 01       	movw	r30, r28
 956:	31 97       	sbiw	r30, 0x01	; 1
 958:	f1 f7       	brne	.-4      	; 0x956 <main+0x252>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 95a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 95c:	d9 f7       	brne	.-10     	; 0x954 <main+0x250>
{
_delay_ms(1000);
lcd_command(0x01);
 95e:	81 e0       	ldi	r24, 0x01	; 1
 960:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 964:	80 e8       	ldi	r24, 0x80	; 128
 966:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string(A);
 96a:	82 e0       	ldi	r24, 0x02	; 2
 96c:	91 e0       	ldi	r25, 0x01	; 1
 96e:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 972:	80 e1       	ldi	r24, 0x10	; 16
 974:	97 e2       	ldi	r25, 0x27	; 39
 976:	fe 01       	movw	r30, r28
 978:	31 97       	sbiw	r30, 0x01	; 1
 97a:	f1 f7       	brne	.-4      	; 0x978 <main+0x274>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 97c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 97e:	d9 f7       	brne	.-10     	; 0x976 <main+0x272>
_delay_ms(1000);
lcd_command(0x01);
 980:	81 e0       	ldi	r24, 0x01	; 1
 982:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 986:	80 e8       	ldi	r24, 0x80	; 128
 988:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
passinput();
 98c:	0e 94 3a 01 	call	0x274	; 0x274 <passinput>
}

if(choice==3)
 990:	80 91 ee 00 	lds	r24, 0x00EE
 994:	90 91 ef 00 	lds	r25, 0x00EF
 998:	03 97       	sbiw	r24, 0x03	; 3
 99a:	09 f0       	breq	.+2      	; 0x99e <main+0x29a>
 99c:	4e c1       	rjmp	.+668    	; 0xc3a <main+0x536>
{
al=strlen(A);
 99e:	f3 01       	movw	r30, r6
 9a0:	01 90       	ld	r0, Z+
 9a2:	00 20       	and	r0, r0
 9a4:	e9 f7       	brne	.-6      	; 0x9a0 <main+0x29c>
 9a6:	31 97       	sbiw	r30, 0x01	; 1
 9a8:	e2 50       	subi	r30, 0x02	; 2
 9aa:	f1 40       	sbci	r31, 0x01	; 1
 9ac:	f0 93 27 01 	sts	0x0127, r31
 9b0:	e0 93 26 01 	sts	0x0126, r30
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 9b4:	e1 99       	sbic	0x1c, 1	; 28
 9b6:	fe cf       	rjmp	.-4      	; 0x9b4 <main+0x2b0>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9b8:	1f bb       	out	0x1f, r17	; 31
 9ba:	0e bb       	out	0x1e, r16	; 30
#endif
    EECR |= (1 << EERE);
 9bc:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
 9be:	8d b3       	in	r24, 0x1d	; 29
bl=eeprom_read_byte(0x070);
 9c0:	68 2f       	mov	r22, r24
 9c2:	70 e0       	ldi	r23, 0x00	; 0
 9c4:	70 93 13 01 	sts	0x0113, r23
 9c8:	60 93 12 01 	sts	0x0112, r22
 9cc:	e4 e1       	ldi	r30, 0x14	; 20
 9ce:	f1 e0       	ldi	r31, 0x01	; 1
 9d0:	20 e0       	ldi	r18, 0x00	; 0
 9d2:	30 e0       	ldi	r19, 0x00	; 0
 9d4:	40 e3       	ldi	r20, 0x30	; 48
 9d6:	0c c0       	rjmp	.+24     	; 0x9f0 <main+0x2ec>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
 9d8:	e1 99       	sbic	0x1c, 1	; 28
 9da:	fe cf       	rjmp	.-4      	; 0x9d8 <main+0x2d4>
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 9dc:	84 2f       	mov	r24, r20
 9de:	90 e0       	ldi	r25, 0x00	; 0
 9e0:	9f bb       	out	0x1f, r25	; 31
 9e2:	8e bb       	out	0x1e, r24	; 30
#endif
    EECR |= (1 << EERE);
 9e4:	e0 9a       	sbi	0x1c, 0	; 28
    return EEDR;
 9e6:	8d b3       	in	r24, 0x1d	; 29
e=0x030;
for(i=0;i<bl;i++)
{
B[i]=eeprom_read_byte(e);
 9e8:	81 93       	st	Z+, r24
 9ea:	2f 5f       	subi	r18, 0xFF	; 255
 9ec:	3f 4f       	sbci	r19, 0xFF	; 255
 9ee:	4f 5f       	subi	r20, 0xFF	; 255
if(choice==3)
{
al=strlen(A);
bl=eeprom_read_byte(0x070);
e=0x030;
for(i=0;i<bl;i++)
 9f0:	26 17       	cp	r18, r22
 9f2:	37 07       	cpc	r19, r23
 9f4:	8c f3       	brlt	.-30     	; 0x9d8 <main+0x2d4>
 9f6:	40 93 e8 00 	sts	0x00E8, r20
 9fa:	30 93 25 01 	sts	0x0125, r19
 9fe:	20 93 24 01 	sts	0x0124, r18
{
B[i]=eeprom_read_byte(e);
e++;
}

lcd_command(0x01);
 a02:	81 e0       	ldi	r24, 0x01	; 1
 a04:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 a08:	80 e8       	ldi	r24, 0x80	; 128
 a0a:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("Checking password");
 a0e:	8c e7       	ldi	r24, 0x7C	; 124
 a10:	90 e0       	ldi	r25, 0x00	; 0
 a12:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 a16:	80 e1       	ldi	r24, 0x10	; 16
 a18:	97 e2       	ldi	r25, 0x27	; 39
 a1a:	fe 01       	movw	r30, r28
 a1c:	31 97       	sbiw	r30, 0x01	; 1
 a1e:	f1 f7       	brne	.-4      	; 0xa1c <main+0x318>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 a20:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 a22:	d9 f7       	brne	.-10     	; 0xa1a <main+0x316>
_delay_ms(1000);
lcd_command(0x01);
 a24:	81 e0       	ldi	r24, 0x01	; 1
 a26:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 a2a:	80 e8       	ldi	r24, 0x80	; 128
 a2c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
if(al==bl)
 a30:	20 91 26 01 	lds	r18, 0x0126
 a34:	30 91 27 01 	lds	r19, 0x0127
 a38:	80 91 12 01 	lds	r24, 0x0112
 a3c:	90 91 13 01 	lds	r25, 0x0113
 a40:	28 17       	cp	r18, r24
 a42:	39 07       	cpc	r19, r25
 a44:	09 f0       	breq	.+2      	; 0xa48 <main+0x344>
 a46:	f1 c0       	rjmp	.+482    	; 0xc2a <main+0x526>
{
lcd_command(0x01);
 a48:	81 e0       	ldi	r24, 0x01	; 1
 a4a:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 a4e:	80 e8       	ldi	r24, 0x80	; 128
 a50:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("Length Matched");
 a54:	8e e8       	ldi	r24, 0x8E	; 142
 a56:	90 e0       	ldi	r25, 0x00	; 0
 a58:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 a5c:	80 e1       	ldi	r24, 0x10	; 16
 a5e:	97 e2       	ldi	r25, 0x27	; 39
 a60:	fe 01       	movw	r30, r28
 a62:	31 97       	sbiw	r30, 0x01	; 1
 a64:	f1 f7       	brne	.-4      	; 0xa62 <main+0x35e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 a66:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 a68:	d9 f7       	brne	.-10     	; 0xa60 <main+0x35c>
_delay_ms(1000);
lcd_command(0x01);
 a6a:	81 e0       	ldi	r24, 0x01	; 1
 a6c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 a70:	80 e8       	ldi	r24, 0x80	; 128
 a72:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
for (i=0;i<al;i++)
 a76:	10 92 25 01 	sts	0x0125, r1
 a7a:	10 92 24 01 	sts	0x0124, r1
 a7e:	3f c0       	rjmp	.+126    	; 0xafe <main+0x3fa>
 a80:	80 e1       	ldi	r24, 0x10	; 16
 a82:	97 e2       	ldi	r25, 0x27	; 39
 a84:	fe 01       	movw	r30, r28
 a86:	31 97       	sbiw	r30, 0x01	; 1
 a88:	f1 f7       	brne	.-4      	; 0xa86 <main+0x382>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 a8a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 a8c:	d9 f7       	brne	.-10     	; 0xa84 <main+0x380>
{
_delay_ms(1000);
lcd_command(0x01);
 a8e:	81 e0       	ldi	r24, 0x01	; 1
 a90:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x81);
 a94:	81 e8       	ldi	r24, 0x81	; 129
 a96:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_data(A[i]);
 a9a:	e0 91 24 01 	lds	r30, 0x0124
 a9e:	f0 91 25 01 	lds	r31, 0x0125
 aa2:	ee 5f       	subi	r30, 0xFE	; 254
 aa4:	fe 4f       	sbci	r31, 0xFE	; 254
 aa6:	80 81       	ld	r24, Z
 aa8:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>
lcd_command(0x89);
 aac:	89 e8       	ldi	r24, 0x89	; 137
 aae:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_data(B[i]);
 ab2:	e0 91 24 01 	lds	r30, 0x0124
 ab6:	f0 91 25 01 	lds	r31, 0x0125
 aba:	ec 5e       	subi	r30, 0xEC	; 236
 abc:	fe 4f       	sbci	r31, 0xFE	; 254
 abe:	80 81       	ld	r24, Z
 ac0:	0e 94 73 00 	call	0xe6	; 0xe6 <lcd_data>

if(A[i]==B[i])
 ac4:	20 91 24 01 	lds	r18, 0x0124
 ac8:	30 91 25 01 	lds	r19, 0x0125
 acc:	f9 01       	movw	r30, r18
 ace:	ee 5f       	subi	r30, 0xFE	; 254
 ad0:	fe 4f       	sbci	r31, 0xFE	; 254
 ad2:	d9 01       	movw	r26, r18
 ad4:	ac 5e       	subi	r26, 0xEC	; 236
 ad6:	be 4f       	sbci	r27, 0xFE	; 254
 ad8:	90 81       	ld	r25, Z
 ada:	8c 91       	ld	r24, X
 adc:	98 17       	cp	r25, r24
 ade:	49 f4       	brne	.+18     	; 0xaf2 <main+0x3ee>
{
p++;
 ae0:	80 91 f0 00 	lds	r24, 0x00F0
 ae4:	90 91 f1 00 	lds	r25, 0x00F1
 ae8:	01 96       	adiw	r24, 0x01	; 1
 aea:	90 93 f1 00 	sts	0x00F1, r25
 aee:	80 93 f0 00 	sts	0x00F0, r24
lcd_command(0x80);
lcd_string("Length Matched");
_delay_ms(1000);
lcd_command(0x01);
lcd_command(0x80);
for (i=0;i<al;i++)
 af2:	2f 5f       	subi	r18, 0xFF	; 255
 af4:	3f 4f       	sbci	r19, 0xFF	; 255
 af6:	30 93 25 01 	sts	0x0125, r19
 afa:	20 93 24 01 	sts	0x0124, r18
 afe:	20 91 26 01 	lds	r18, 0x0126
 b02:	30 91 27 01 	lds	r19, 0x0127
 b06:	80 91 24 01 	lds	r24, 0x0124
 b0a:	90 91 25 01 	lds	r25, 0x0125
 b0e:	82 17       	cp	r24, r18
 b10:	93 07       	cpc	r25, r19
 b12:	0c f4       	brge	.+2      	; 0xb16 <main+0x412>
 b14:	b5 cf       	rjmp	.-150    	; 0xa80 <main+0x37c>
{
p++;
}
else;
}
if(p==al)
 b16:	80 91 f0 00 	lds	r24, 0x00F0
 b1a:	90 91 f1 00 	lds	r25, 0x00F1
 b1e:	82 17       	cp	r24, r18
 b20:	93 07       	cpc	r25, r19
 b22:	09 f0       	breq	.+2      	; 0xb26 <main+0x422>
 b24:	75 c0       	rjmp	.+234    	; 0xc10 <main+0x50c>
 b26:	80 e1       	ldi	r24, 0x10	; 16
 b28:	97 e2       	ldi	r25, 0x27	; 39
 b2a:	fe 01       	movw	r30, r28
 b2c:	31 97       	sbiw	r30, 0x01	; 1
 b2e:	f1 f7       	brne	.-4      	; 0xb2c <main+0x428>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 b30:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 b32:	d9 f7       	brne	.-10     	; 0xb2a <main+0x426>
{
_delay_ms(1000);
lcd_command(0x01);
 b34:	81 e0       	ldi	r24, 0x01	; 1
 b36:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 b3a:	80 e8       	ldi	r24, 0x80	; 128
 b3c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("Password Matched");
 b40:	8d e9       	ldi	r24, 0x9D	; 157
 b42:	90 e0       	ldi	r25, 0x00	; 0
 b44:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
PORTB=255;
 b48:	58 ba       	out	0x18, r5	; 24
 b4a:	80 e1       	ldi	r24, 0x10	; 16
 b4c:	97 e2       	ldi	r25, 0x27	; 39
 b4e:	fe 01       	movw	r30, r28
 b50:	31 97       	sbiw	r30, 0x01	; 1
 b52:	f1 f7       	brne	.-4      	; 0xb50 <main+0x44c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 b54:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 b56:	d9 f7       	brne	.-10     	; 0xb4e <main+0x44a>
_delay_ms(1000);
lcd_command(0x01);
 b58:	81 e0       	ldi	r24, 0x01	; 1
 b5a:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 b5e:	80 e8       	ldi	r24, 0x80	; 128
 b60:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("*:Change Password");
 b64:	8e ea       	ldi	r24, 0xAE	; 174
 b66:	90 e0       	ldi	r25, 0x00	; 0
 b68:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 b6c:	80 e1       	ldi	r24, 0x10	; 16
 b6e:	97 e2       	ldi	r25, 0x27	; 39
 b70:	fe 01       	movw	r30, r28
 b72:	31 97       	sbiw	r30, 0x01	; 1
 b74:	f1 f7       	brne	.-4      	; 0xb72 <main+0x46e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 b76:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 b78:	d9 f7       	brne	.-10     	; 0xb70 <main+0x46c>
_delay_ms(1000);
lcd_command(0x01);
 b7a:	81 e0       	ldi	r24, 0x01	; 1
 b7c:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 b80:	80 e8       	ldi	r24, 0x80	; 128
 b82:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("#:Unlock");
 b86:	80 ec       	ldi	r24, 0xC0	; 192
 b88:	90 e0       	ldi	r25, 0x00	; 0
 b8a:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 b8e:	80 e1       	ldi	r24, 0x10	; 16
 b90:	97 e2       	ldi	r25, 0x27	; 39
 b92:	fe 01       	movw	r30, r28
 b94:	31 97       	sbiw	r30, 0x01	; 1
 b96:	f1 f7       	brne	.-4      	; 0xb94 <main+0x490>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 b98:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 b9a:	d9 f7       	brne	.-10     	; 0xb92 <main+0x48e>
_delay_ms(1000);
PORTB=0;
 b9c:	18 ba       	out	0x18, r1	; 24
PORTD=0x7f;
 b9e:	8f e7       	ldi	r24, 0x7F	; 127
 ba0:	82 bb       	out	0x12, r24	; 18
while((PIND&0x0f)==0x0f);
 ba2:	80 b3       	in	r24, 0x10	; 16
 ba4:	8f 70       	andi	r24, 0x0F	; 15
 ba6:	8f 30       	cpi	r24, 0x0F	; 15
 ba8:	e1 f3       	breq	.-8      	; 0xba2 <main+0x49e>
while(1)
{
if((PIND&0x01)==0)
 baa:	80 99       	sbic	0x10, 0	; 16
 bac:	21 c0       	rjmp	.+66     	; 0xbf0 <main+0x4ec>
{
while((PIND&0x01)==0);
 bae:	80 9b       	sbis	0x10, 0	; 16
 bb0:	fe cf       	rjmp	.-4      	; 0xbae <main+0x4aa>
PORTB=0b10101010;
 bb2:	8a ea       	ldi	r24, 0xAA	; 170
 bb4:	88 bb       	out	0x18, r24	; 24
 bb6:	80 e1       	ldi	r24, 0x10	; 16
 bb8:	97 e2       	ldi	r25, 0x27	; 39
 bba:	fe 01       	movw	r30, r28
 bbc:	31 97       	sbiw	r30, 0x01	; 1
 bbe:	f1 f7       	brne	.-4      	; 0xbbc <main+0x4b8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 bc0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 bc2:	d9 f7       	brne	.-10     	; 0xbba <main+0x4b6>
_delay_ms(1000);
PORTB=0b01010101;
 bc4:	85 e5       	ldi	r24, 0x55	; 85
 bc6:	88 bb       	out	0x18, r24	; 24
set=2;
 bc8:	90 92 2b 01 	sts	0x012B, r9
 bcc:	80 92 2a 01 	sts	0x012A, r8
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
 bd0:	e1 99       	sbic	0x1c, 1	; 28
 bd2:	fe cf       	rjmp	.-4      	; 0xbd0 <main+0x4cc>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
 bd4:	ff ba       	out	0x1f, r15	; 31
 bd6:	ee ba       	out	0x1e, r14	; 30
#endif
    EEDR = __value;
 bd8:	82 e0       	ldi	r24, 0x02	; 2
 bda:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
 bdc:	0f b6       	in	r0, 0x3f	; 63
 bde:	f8 94       	cli
 be0:	e2 9a       	sbi	0x1c, 2	; 28
 be2:	e1 9a       	sbi	0x1c, 1	; 28
 be4:	0f be       	out	0x3f, r0	; 63
eeprom_write_byte(0x072,set);
choice=1;
 be6:	d0 92 ef 00 	sts	0x00EF, r13
 bea:	c0 92 ee 00 	sts	0x00EE, r12
 bee:	25 c0       	rjmp	.+74     	; 0xc3a <main+0x536>
break;
}
if((PIND&0x04)==0)
 bf0:	82 99       	sbic	0x10, 2	; 16
 bf2:	db cf       	rjmp	.-74     	; 0xbaa <main+0x4a6>
{
while((PIND&0x04)==0);
 bf4:	82 9b       	sbis	0x10, 2	; 16
 bf6:	fe cf       	rjmp	.-4      	; 0xbf4 <main+0x4f0>
PORTB=255;
 bf8:	58 ba       	out	0x18, r5	; 24
lcd_command(0x01);
 bfa:	81 e0       	ldi	r24, 0x01	; 1
 bfc:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 c00:	80 e8       	ldi	r24, 0x80	; 128
 c02:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_string("Access Granted");
 c06:	89 ec       	ldi	r24, 0xC9	; 201
 c08:	90 e0       	ldi	r25, 0x00	; 0
 c0a:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 c0e:	15 c0       	rjmp	.+42     	; 0xc3a <main+0x536>
break;
 c10:	80 e1       	ldi	r24, 0x10	; 16
 c12:	97 e2       	ldi	r25, 0x27	; 39
 c14:	fe 01       	movw	r30, r28
 c16:	31 97       	sbiw	r30, 0x01	; 1
 c18:	f1 f7       	brne	.-4      	; 0xc16 <main+0x512>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 c1a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 c1c:	d9 f7       	brne	.-10     	; 0xc14 <main+0x510>
}

else if(p!=al)
{
_delay_ms(1000);
lcd_command(0x01);
 c1e:	81 e0       	ldi	r24, 0x01	; 1
 c20:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80); 
 c24:	80 e8       	ldi	r24, 0x80	; 128
 c26:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
choice=4;
}
}
else 
{
lcd_string("Wrong Password");
 c2a:	88 ed       	ldi	r24, 0xD8	; 216
 c2c:	90 e0       	ldi	r25, 0x00	; 0
 c2e:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
choice=4;}
 c32:	b0 92 ef 00 	sts	0x00EF, r11
 c36:	a0 92 ee 00 	sts	0x00EE, r10
}

if(choice==4)
 c3a:	80 91 ee 00 	lds	r24, 0x00EE
 c3e:	90 91 ef 00 	lds	r25, 0x00EF
 c42:	04 97       	sbiw	r24, 0x04	; 4
 c44:	09 f0       	breq	.+2      	; 0xc48 <main+0x544>
 c46:	8b cd       	rjmp	.-1258   	; 0x75e <main+0x5a>
 c48:	80 e1       	ldi	r24, 0x10	; 16
 c4a:	97 e2       	ldi	r25, 0x27	; 39
 c4c:	fe 01       	movw	r30, r28
 c4e:	31 97       	sbiw	r30, 0x01	; 1
 c50:	f1 f7       	brne	.-4      	; 0xc4e <main+0x54a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 c52:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 c54:	d9 f7       	brne	.-10     	; 0xc4c <main+0x548>
{
_delay_ms(1000);
lcd_command(0x01);
 c56:	81 e0       	ldi	r24, 0x01	; 1
 c58:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 c5c:	80 e8       	ldi	r24, 0x80	; 128
 c5e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
 c62:	80 e1       	ldi	r24, 0x10	; 16
 c64:	97 e2       	ldi	r25, 0x27	; 39
 c66:	fe 01       	movw	r30, r28
 c68:	31 97       	sbiw	r30, 0x01	; 1
 c6a:	f1 f7       	brne	.-4      	; 0xc68 <main+0x564>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 c6c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 c6e:	d9 f7       	brne	.-10     	; 0xc66 <main+0x562>
_delay_ms(1000);
lcd_string("Enter Password");
 c70:	80 e6       	ldi	r24, 0x60	; 96
 c72:	90 e0       	ldi	r25, 0x00	; 0
 c74:	0e 94 8c 00 	call	0x118	; 0x118 <lcd_string>
 c78:	80 e1       	ldi	r24, 0x10	; 16
 c7a:	97 e2       	ldi	r25, 0x27	; 39
 c7c:	fe 01       	movw	r30, r28
 c7e:	31 97       	sbiw	r30, 0x01	; 1
 c80:	f1 f7       	brne	.-4      	; 0xc7e <main+0x57a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 c82:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 c84:	d9 f7       	brne	.-10     	; 0xc7c <main+0x578>
_delay_ms(1000);
lcd_command(0x01);
 c86:	81 e0       	ldi	r24, 0x01	; 1
 c88:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
lcd_command(0x80);
 c8c:	80 e8       	ldi	r24, 0x80	; 128
 c8e:	0e 94 49 00 	call	0x92	; 0x92 <lcd_command>
passinput();
 c92:	0e 94 3a 01 	call	0x274	; 0x274 <passinput>
 c96:	63 cd       	rjmp	.-1338   	; 0x75e <main+0x5a>

00000c98 <__eewr_block>:
 c98:	a0 e0       	ldi	r26, 0x00	; 0
 c9a:	b0 e0       	ldi	r27, 0x00	; 0
 c9c:	e2 e5       	ldi	r30, 0x52	; 82
 c9e:	f6 e0       	ldi	r31, 0x06	; 6
 ca0:	0c 94 86 06 	jmp	0xd0c	; 0xd0c <__prologue_saves__+0x14>
 ca4:	ec 01       	movw	r28, r24
 ca6:	7b 01       	movw	r14, r22
 ca8:	8a 01       	movw	r16, r20
 caa:	69 01       	movw	r12, r18
 cac:	09 c0       	rjmp	.+18     	; 0xcc0 <__eewr_block+0x28>
 cae:	f7 01       	movw	r30, r14
 cb0:	61 91       	ld	r22, Z+
 cb2:	7f 01       	movw	r14, r30
 cb4:	ce 01       	movw	r24, r28
 cb6:	21 96       	adiw	r28, 0x01	; 1
 cb8:	f6 01       	movw	r30, r12
 cba:	09 95       	icall
 cbc:	01 50       	subi	r16, 0x01	; 1
 cbe:	10 40       	sbci	r17, 0x00	; 0
 cc0:	01 15       	cp	r16, r1
 cc2:	11 05       	cpc	r17, r1
 cc4:	a1 f7       	brne	.-24     	; 0xcae <__eewr_block+0x16>
 cc6:	cd b7       	in	r28, 0x3d	; 61
 cc8:	de b7       	in	r29, 0x3e	; 62
 cca:	e8 e0       	ldi	r30, 0x08	; 8
 ccc:	0c 94 a2 06 	jmp	0xd44	; 0xd44 <__epilogue_restores__+0x14>

00000cd0 <__udivmodhi4>:
 cd0:	aa 1b       	sub	r26, r26
 cd2:	bb 1b       	sub	r27, r27
 cd4:	51 e1       	ldi	r21, 0x11	; 17
 cd6:	07 c0       	rjmp	.+14     	; 0xce6 <__udivmodhi4_ep>

00000cd8 <__udivmodhi4_loop>:
 cd8:	aa 1f       	adc	r26, r26
 cda:	bb 1f       	adc	r27, r27
 cdc:	a6 17       	cp	r26, r22
 cde:	b7 07       	cpc	r27, r23
 ce0:	10 f0       	brcs	.+4      	; 0xce6 <__udivmodhi4_ep>
 ce2:	a6 1b       	sub	r26, r22
 ce4:	b7 0b       	sbc	r27, r23

00000ce6 <__udivmodhi4_ep>:
 ce6:	88 1f       	adc	r24, r24
 ce8:	99 1f       	adc	r25, r25
 cea:	5a 95       	dec	r21
 cec:	a9 f7       	brne	.-22     	; 0xcd8 <__udivmodhi4_loop>
 cee:	80 95       	com	r24
 cf0:	90 95       	com	r25
 cf2:	bc 01       	movw	r22, r24
 cf4:	cd 01       	movw	r24, r26
 cf6:	08 95       	ret

00000cf8 <__prologue_saves__>:
 cf8:	2f 92       	push	r2
 cfa:	3f 92       	push	r3
 cfc:	4f 92       	push	r4
 cfe:	5f 92       	push	r5
 d00:	6f 92       	push	r6
 d02:	7f 92       	push	r7
 d04:	8f 92       	push	r8
 d06:	9f 92       	push	r9
 d08:	af 92       	push	r10
 d0a:	bf 92       	push	r11
 d0c:	cf 92       	push	r12
 d0e:	df 92       	push	r13
 d10:	ef 92       	push	r14
 d12:	ff 92       	push	r15
 d14:	0f 93       	push	r16
 d16:	1f 93       	push	r17
 d18:	cf 93       	push	r28
 d1a:	df 93       	push	r29
 d1c:	cd b7       	in	r28, 0x3d	; 61
 d1e:	de b7       	in	r29, 0x3e	; 62
 d20:	ca 1b       	sub	r28, r26
 d22:	db 0b       	sbc	r29, r27
 d24:	0f b6       	in	r0, 0x3f	; 63
 d26:	f8 94       	cli
 d28:	de bf       	out	0x3e, r29	; 62
 d2a:	0f be       	out	0x3f, r0	; 63
 d2c:	cd bf       	out	0x3d, r28	; 61
 d2e:	09 94       	ijmp

00000d30 <__epilogue_restores__>:
 d30:	2a 88       	ldd	r2, Y+18	; 0x12
 d32:	39 88       	ldd	r3, Y+17	; 0x11
 d34:	48 88       	ldd	r4, Y+16	; 0x10
 d36:	5f 84       	ldd	r5, Y+15	; 0x0f
 d38:	6e 84       	ldd	r6, Y+14	; 0x0e
 d3a:	7d 84       	ldd	r7, Y+13	; 0x0d
 d3c:	8c 84       	ldd	r8, Y+12	; 0x0c
 d3e:	9b 84       	ldd	r9, Y+11	; 0x0b
 d40:	aa 84       	ldd	r10, Y+10	; 0x0a
 d42:	b9 84       	ldd	r11, Y+9	; 0x09
 d44:	c8 84       	ldd	r12, Y+8	; 0x08
 d46:	df 80       	ldd	r13, Y+7	; 0x07
 d48:	ee 80       	ldd	r14, Y+6	; 0x06
 d4a:	fd 80       	ldd	r15, Y+5	; 0x05
 d4c:	0c 81       	ldd	r16, Y+4	; 0x04
 d4e:	1b 81       	ldd	r17, Y+3	; 0x03
 d50:	aa 81       	ldd	r26, Y+2	; 0x02
 d52:	b9 81       	ldd	r27, Y+1	; 0x01
 d54:	ce 0f       	add	r28, r30
 d56:	d1 1d       	adc	r29, r1
 d58:	0f b6       	in	r0, 0x3f	; 63
 d5a:	f8 94       	cli
 d5c:	de bf       	out	0x3e, r29	; 62
 d5e:	0f be       	out	0x3f, r0	; 63
 d60:	cd bf       	out	0x3d, r28	; 61
 d62:	ed 01       	movw	r28, r26
 d64:	08 95       	ret

00000d66 <_exit>:
 d66:	f8 94       	cli

00000d68 <__stop_program>:
 d68:	ff cf       	rjmp	.-2      	; 0xd68 <__stop_program>
